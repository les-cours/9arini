{"ast":null,"code":"var _jsxFileName = \"/home/chouaib/code/learn/frontend/contexts/AuthContext.tsx\";\nvar __jsx = React.createElement;\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport React, { useState, useEffect, useCallback, useRef } from \"react\";\nimport Axios from \"axios\";\nimport jwt from \"jwt-decode\";\nimport { isEqual } from \"lodash\";\nimport client from \"./Auth\";\nimport { AuthCtx } from \"./AuthCtx\";\nconst AuthProvider = ({\n  children\n}) => {\n  const {\n    0: auth,\n    1: setAuth\n  } = useState({\n    authenticated: false,\n    agent: {}\n  });\n  const {\n    0: checkingToken,\n    1: setCheckingToken\n  } = useState(true);\n  const tokenRef = useRef(void 0);\n  const tokenTypeRef = useRef(void 0);\n  const callBackURLRef = useRef(void 0);\n  const tokenExipresAtRef = useRef(0);\n  const tokenRefreshTimoutRef = useRef(0);\n  const onLoginSucceedHandlerRef = useRef(function () {});\n  const cleaners = useRef(null);\n  const onSaveTokenHandler = useCallback(userAuth => {\n    var _userAuth$user, _userAuth$user2;\n    window.localStorage.setItem(\"id_token\", (_userAuth$user = userAuth.user) === null || _userAuth$user === void 0 ? void 0 : _userAuth$user.accessToken);\n    window.localStorage.setItem(\"token_type\", (_userAuth$user2 = userAuth.user) === null || _userAuth$user2 === void 0 ? void 0 : _userAuth$user2.tokenType);\n  }, []);\n  const onLogOutHandler = useCallback(async () => {\n    try {\n      clearTimeout(tokenRefreshTimoutRef.current);\n      await Axios.post(`${process.env.APP_AUTH_SERVICE}logout`, null, {\n        withCredentials: true\n      });\n      setAuth({\n        authenticated: false,\n        agent: {}\n      });\n      cleaners.current();\n      localStorage.removeItem(\"id_token\");\n      return true;\n    } catch (error) {\n      console.error(error);\n      return false;\n    }\n  }, [history]);\n  onLoginSucceedHandlerRef.current = userAuth => {\n    const {\n      accessToken,\n      tokenType,\n      expiresIn\n    } = userAuth.user;\n    const userDetails = jwt(accessToken);\n    tokenRef.current = accessToken;\n    tokenTypeRef.current = tokenType;\n    tokenExipresAtRef.current = expiresIn;\n    //@ts-ignore\n    userDetails.agentID = userDetails.id;\n    delete userDetails.exp;\n    if (auth.authenticated && isEqual(auth.agent, userDetails)) {\n      // Same user details no need to re-render\n      return;\n    }\n    setAuth(_objectSpread({\n      authenticated: true,\n      agent: userDetails\n    }, userDetails));\n  };\n  const onRefreshTokenHandler = useCallback(expireAt => {\n    let numberOfRetry = 0;\n    async function refresh() {\n      try {\n        const {\n          data: userAuth\n        } = await Axios.post(`${process.env.APP_AUTH_SERVICE}refresh`, null, {\n          withCredentials: true\n        });\n        onLoginSucceedHandlerRef.current(userAuth);\n        onSaveTokenHandler(userAuth);\n        onRefreshTokenHandler(userAuth.user.expiresIn * 1000);\n      } catch (error) {\n        numberOfRetry++;\n        console.error(error);\n        if (numberOfRetry > parseInt(process.env.MAX_REFRESH_TOKEN_ATTEMPS)) {\n          onLogOutHandler();\n          return;\n        }\n\n        // Retry again\n        tokenRefreshTimoutRef.current = setTimeout(refresh, 10000);\n      }\n    }\n    tokenRefreshTimoutRef.current = setTimeout(refresh, expireAt - Date.now() - 5000);\n  }, [onLogOutHandler]);\n  const onLoginHandler = useCallback(async login => {\n    try {\n      const osname = getUserOperatingSystem();\n      const {\n        data: userAuth\n      } = await Axios.post(`${process.env.APP_AUTH_SERVICE}login`, _objectSpread(_objectSpread({}, login), {}, {\n        osname\n      }), {\n        withCredentials: true,\n        headers: {\n          \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\"\n        },\n        validateStatus() {\n          return true;\n        }\n      });\n      if (typeof userAuth.error === \"object\") {\n        setAuth({\n          authenticated: false,\n          agent: {}\n        });\n        return {\n          error: userAuth.error\n        };\n      }\n      onLoginSucceedHandlerRef.current(userAuth);\n      onSaveTokenHandler(userAuth);\n      onRefreshTokenHandler(userAuth.user.expiresIn * 1000);\n      return {\n        token: `${userAuth.user.tokenType} ${userAuth.user.accessToken}`\n      };\n    } catch (e) {\n      setAuth({\n        authenticated: false,\n        agent: {}\n      });\n      return {\n        error: {\n          message: e.message\n        }\n      };\n    }\n  }, [client]);\n  const authenticateToken = useCallback(async (triggerAutoRefresh = false) => {\n    try {\n      if (triggerAutoRefresh) {\n        setCheckingToken(true);\n      }\n      const {\n        data: userAuth\n      } = await Axios.post(`${process.env.APP_AUTH_SERVICE}refresh`, null, {\n        withCredentials: true\n      });\n      onLoginSucceedHandlerRef.current(userAuth);\n      onSaveTokenHandler(userAuth);\n      if (triggerAutoRefresh) {\n        onRefreshTokenHandler(userAuth.user.expiresIn * 1000);\n      }\n      return true;\n    } catch (error) {\n      console.error(error);\n      return false;\n    } finally {\n      if (triggerAutoRefresh) {\n        setCheckingToken(false);\n      }\n    }\n  }, [client]);\n  const onSignupRedirectHandler = useCallback(async (token, tokenType) => {\n    try {\n      const details = jwt(token);\n      tokenRef.current = token;\n      tokenTypeRef.current = tokenType;\n      tokenExipresAtRef.current = details === null || details === void 0 ? void 0 : details.exp;\n      onRefreshTokenHandler((details === null || details === void 0 ? void 0 : details.exp) * 1000);\n      setAuth(_objectSpread({\n        authenticated: true,\n        agent: details\n      }, details));\n      return true;\n    } catch (error) {\n      console.error(error);\n      setAuth({\n        authenticated: false,\n        agent: {}\n      });\n      return false;\n    }\n  }, []);\n  const token = useCallback(async () => {\n    // We have 4secondes or more in life the current token\n    if (tokenExipresAtRef.current - Date.now() / 1000 >= 4) {\n      return `${tokenTypeRef.current} ${tokenRef.current}`;\n    }\n    return new Promise(resolver => {\n      let cycleCount = 0;\n      const tokenWaiter = function () {\n        setTimeout(() => {\n          if (tokenExipresAtRef.current - Date.now() / 1000 >= 4) {\n            return resolver(`${tokenTypeRef.current} ${tokenRef.current}`);\n          }\n          cycleCount++;\n          if (cycleCount > 10) {\n            return resolver(\"\");\n          }\n          tokenWaiter();\n        }, 1000);\n      };\n    });\n  }, []);\n  const onAddOnLogoutClean = useCallback(cleanupFunction => {\n    cleaners.current = cleanupFunction;\n  }, []);\n  useEffect(() => {\n    if ([appRoutes.login(), appRoutes.reset(), appRoutes.forgot(), appRoutes.confirm(), appRoutes.signup()].findIndex(route => new RegExp(route.replace(/\\/$/, \"\")).test(window.location.pathname)) === -1) {\n      callBackURLRef.current = window.location.href.replace(window.location.origin, \"\");\n    }\n  }, [window.location.href]);\n  useEffect(() => {\n    authenticateToken(true).then(response => {\n      if (response) {\n        history.push(callBackURLRef.current || appRoutes.webRTC(i18n.language));\n      }\n    });\n  }, []);\n  useEffect(() => {\n    const onLocalStorageChangeHandler = function () {\n      const token = window.localStorage.getItem(\"id_token\");\n      const tokenType = window.localStorage.getItem(\"token_type\");\n      if (typeof token !== \"string\" || typeof tokenType !== \"string\") {\n        onLogOutHandler();\n      }\n    };\n    window.addEventListener(\"storage\", onLocalStorageChangeHandler);\n    return () => {\n      window.removeEventListener(\"storage\", onLocalStorageChangeHandler);\n    };\n  }, []);\n  if (checkingToken) {\n    return __jsx(Loader, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 267,\n        columnNumber: 16\n      }\n    });\n  }\n  return __jsx(AuthCtx.Provider, {\n    value: _objectSpread(_objectSpread({}, auth), {}, {\n      callbackURL: callBackURLRef.current,\n      token,\n      addOnLogoutClean: onAddOnLogoutClean,\n      login: onLoginHandler,\n      logout: onLogOutHandler,\n      refreshTokenNow: authenticateToken,\n      refreshToken: onRefreshTokenHandler,\n      RedirectOnSingupCompletion: onSignupRedirectHandler\n    }),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 270,\n      columnNumber: 9\n    }\n  }, children);\n};\nexport default React.memo(AuthProvider);","map":{"version":3,"names":["React","useState","useEffect","useCallback","useRef","Axios","jwt","isEqual","client","AuthCtx","AuthProvider","children","auth","setAuth","authenticated","agent","checkingToken","setCheckingToken","tokenRef","tokenTypeRef","callBackURLRef","tokenExipresAtRef","tokenRefreshTimoutRef","onLoginSucceedHandlerRef","cleaners","onSaveTokenHandler","userAuth","_userAuth$user","_userAuth$user2","window","localStorage","setItem","user","accessToken","tokenType","onLogOutHandler","clearTimeout","current","post","process","env","APP_AUTH_SERVICE","withCredentials","removeItem","error","console","history","expiresIn","userDetails","agentID","id","exp","_objectSpread","onRefreshTokenHandler","expireAt","numberOfRetry","refresh","data","parseInt","MAX_REFRESH_TOKEN_ATTEMPS","setTimeout","Date","now","onLoginHandler","login","osname","getUserOperatingSystem","headers","validateStatus","token","e","message","authenticateToken","triggerAutoRefresh","onSignupRedirectHandler","details","Promise","resolver","cycleCount","tokenWaiter","onAddOnLogoutClean","cleanupFunction","appRoutes","reset","forgot","confirm","signup","findIndex","route","RegExp","replace","test","location","pathname","href","origin","then","response","push","webRTC","i18n","language","onLocalStorageChangeHandler","getItem","addEventListener","removeEventListener","__jsx","Loader","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","Provider","value","callbackURL","addOnLogoutClean","logout","refreshTokenNow","refreshToken","RedirectOnSingupCompletion","memo"],"sources":["/home/chouaib/code/learn/frontend/contexts/AuthContext.tsx"],"sourcesContent":["import React, { useState, useEffect, useCallback, useRef } from \"react\";\n\nimport Axios from \"axios\";\nimport jwt from \"jwt-decode\";\nimport { isEqual } from \"lodash\";\nimport client from \"./Auth\"\nimport  {AuthCtx}  from \"./AuthCtx\";\n\n\ninterface UserAuth {\n    user?: {\n        accessToken: string;\n        tokenType: string;\n        expiresIn: number;\n    };\n    error?: {\n        message: string;\n    };\n}\n\nconst AuthProvider = ({ children }) => {\n\n    const [auth, setAuth] = useState({ authenticated: false, agent: {} });\n    const [checkingToken, setCheckingToken] = useState(true);\n    const tokenRef = useRef<string | undefined>(void 0);\n    const tokenTypeRef = useRef<string | undefined>(void 0);\n    const callBackURLRef = useRef<string | undefined>(void 0);\n    const tokenExipresAtRef = useRef(0);\n    const tokenRefreshTimoutRef = useRef<NodeJS.Timeout | number>(0);\n    const onLoginSucceedHandlerRef = useRef<(user: UserAuth) => void>(function () {});\n    const cleaners = useRef<() => void>(null);\n\n    const onSaveTokenHandler = useCallback((userAuth: UserAuth) => {\n        window.localStorage.setItem(\"id_token\", userAuth.user?.accessToken);\n        window.localStorage.setItem(\"token_type\", userAuth.user?.tokenType);\n    }, []);\n\n    const onLogOutHandler = useCallback(async () => {\n        try {\n            clearTimeout(tokenRefreshTimoutRef.current as number);\n            await Axios.post(`${process.env.APP_AUTH_SERVICE}logout`, null, {\n                withCredentials: true,\n            });\n            setAuth({ authenticated: false, agent: {} });\n            cleaners.current();\n            localStorage.removeItem(\"id_token\");\n            return true;\n        } catch (error) {\n            console.error(error);\n            return false;\n        }\n    }, [history]);\n\n    onLoginSucceedHandlerRef.current = (userAuth: UserAuth) => {\n        const { accessToken, tokenType, expiresIn } = userAuth.user;\n        const userDetails = jwt(accessToken);\n        tokenRef.current = accessToken;\n        tokenTypeRef.current = tokenType;\n        tokenExipresAtRef.current = expiresIn;\n        //@ts-ignore\n        userDetails.agentID = userDetails.id;\n        delete (userDetails as any).exp;\n        if (auth.authenticated && isEqual(auth.agent, userDetails)) {\n            // Same user details no need to re-render\n            return;\n        }\n\n        setAuth({\n            authenticated: true,\n            agent: userDetails,\n            ...(userDetails as any),\n        });\n    };\n\n    const onRefreshTokenHandler = useCallback(\n        (expireAt: number) => {\n            let numberOfRetry = 0;\n            async function refresh() {\n                try {\n                    const { data: userAuth } = await Axios.post<UserAuth>(\n                        `${process.env.APP_AUTH_SERVICE}refresh`,\n                        null,\n                        { withCredentials: true }\n                    );\n\n                    onLoginSucceedHandlerRef.current(userAuth);\n                    onSaveTokenHandler(userAuth);\n                    onRefreshTokenHandler(userAuth.user.expiresIn * 1000);\n                } catch (error) {\n                    numberOfRetry++;\n                    console.error(error);\n                    if (numberOfRetry > parseInt(process.env.MAX_REFRESH_TOKEN_ATTEMPS)) {\n                        onLogOutHandler();\n                        return;\n                    }\n\n                    // Retry again\n                    tokenRefreshTimoutRef.current = setTimeout(refresh, 10000);\n                }\n            }\n            tokenRefreshTimoutRef.current = setTimeout(refresh, expireAt - Date.now() - 5000);\n        },\n        [onLogOutHandler]\n    );\n\n    const onLoginHandler = useCallback(\n        async (login: {\n            username: string;\n            password: string;\n        }): Promise<{ token?: string; error?: { message: string } }> => {\n            try {\n                const osname = getUserOperatingSystem();\n                const { data: userAuth } = await Axios.post<UserAuth>(\n                    `${process.env.APP_AUTH_SERVICE}login`,\n                    { ...login, osname },\n                    {\n                        withCredentials: true,\n                        headers: {\n                            \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\",\n                        },\n                        validateStatus() {\n                            return true;\n                        },\n                    }\n                );\n                if (typeof userAuth.error === \"object\") {\n                    setAuth({ authenticated: false, agent: {} });\n                    return { error: userAuth.error };\n                }\n\n                onLoginSucceedHandlerRef.current(userAuth);\n                onSaveTokenHandler(userAuth);\n                onRefreshTokenHandler(userAuth.user.expiresIn * 1000);\n                return { token: `${userAuth.user.tokenType} ${userAuth.user.accessToken}` };\n            } catch (e) {\n                setAuth({ authenticated: false, agent: {} });\n                return { error: { message: e.message } };\n            }\n        },\n        [client]\n    );\n\n    const authenticateToken = useCallback(\n        async (triggerAutoRefresh = false): Promise<boolean> => {\n            try {\n                if (triggerAutoRefresh) {\n                    setCheckingToken(true);\n                }\n\n                const { data: userAuth } = await Axios.post<UserAuth>(\n                    `${process.env.APP_AUTH_SERVICE}refresh`,\n                    null,\n                    { withCredentials: true }\n                );\n\n                onLoginSucceedHandlerRef.current(userAuth);\n                onSaveTokenHandler(userAuth);\n                if (triggerAutoRefresh) {\n                    onRefreshTokenHandler(userAuth.user.expiresIn * 1000);\n                }\n\n                return true;\n            } catch (error) {\n                console.error(error);\n                return false;\n            } finally {\n                if (triggerAutoRefresh) {\n                    setCheckingToken(false);\n                }\n            }\n        },\n        [client]\n    );\n\n    const onSignupRedirectHandler = useCallback(\n        async (token: string, tokenType: string): Promise<boolean> => {\n            try {\n                const details: any = jwt(token);\n                tokenRef.current = token;\n                tokenTypeRef.current = tokenType;\n                tokenExipresAtRef.current = details?.exp;\n                onRefreshTokenHandler(details?.exp * 1000);\n                setAuth({\n                    authenticated: true,\n                    agent: details,\n                    ...(details as any),\n                });\n                return true;\n            } catch (error) {\n                console.error(error);\n                setAuth({ authenticated: false, agent: {} });\n                return false;\n            }\n        },\n        []\n    );\n\n    const token = useCallback(async (): Promise<string> => {\n        // We have 4secondes or more in life the current token\n        if (tokenExipresAtRef.current - Date.now() / 1000 >= 4) {\n            return `${tokenTypeRef.current} ${tokenRef.current}`;\n        }\n\n        return new Promise((resolver) => {\n            let cycleCount = 0;\n            const tokenWaiter = function () {\n                setTimeout(() => {\n                    if (tokenExipresAtRef.current - Date.now() / 1000 >= 4) {\n                        return resolver(`${tokenTypeRef.current} ${tokenRef.current}`);\n                    }\n\n                    cycleCount++;\n                    if (cycleCount > 10) {\n                        return resolver(\"\");\n                    }\n\n                    tokenWaiter();\n                }, 1000);\n            };\n        });\n    }, []);\n\n    const onAddOnLogoutClean = useCallback((cleanupFunction: () => void) => {\n        cleaners.current = cleanupFunction;\n    }, []);\n\n    useEffect(() => {\n        if (\n            [\n                appRoutes.login(),\n                appRoutes.reset(),\n                appRoutes.forgot(),\n                appRoutes.confirm(),\n                appRoutes.signup(),\n            ].findIndex((route) =>\n                new RegExp(route.replace(/\\/$/, \"\")).test(window.location.pathname)\n            ) === -1\n        ) {\n            callBackURLRef.current = window.location.href.replace(window.location.origin, \"\");\n        }\n    }, [window.location.href]);\n\n    useEffect(() => {\n        authenticateToken(true).then((response) => {\n            if (response) {\n                history.push(callBackURLRef.current || appRoutes.webRTC(i18n.language));\n            }\n        });\n    }, []);\n\n    useEffect(() => {\n        const onLocalStorageChangeHandler = function () {\n            const token = window.localStorage.getItem(\"id_token\");\n            const tokenType = window.localStorage.getItem(\"token_type\");\n            if (typeof token !== \"string\" || typeof tokenType !== \"string\") {\n                onLogOutHandler();\n            }\n        };\n\n        window.addEventListener(\"storage\", onLocalStorageChangeHandler);\n        return () => {\n            window.removeEventListener(\"storage\", onLocalStorageChangeHandler);\n        };\n    }, []);\n\n    if (checkingToken) {\n        return <Loader />;\n    }\n    return (\n        <AuthCtx.Provider\n            value={{\n                ...auth,\n                callbackURL: callBackURLRef.current,\n                token,\n                addOnLogoutClean: onAddOnLogoutClean,\n                login: onLoginHandler,\n                logout: onLogOutHandler,\n                refreshTokenNow: authenticateToken,\n                refreshToken: onRefreshTokenHandler,\n                RedirectOnSingupCompletion: onSignupRedirectHandler,\n            }}\n        >\n            {children}\n        </AuthCtx.Provider>\n    );\n};\n\nexport default React.memo(AuthProvider);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}